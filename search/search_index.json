{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Insanus Mokrassar libraries home","text":"<p>Hello :) It is my libraries docs place and I glad to welcome you here. I hope, this documentation place will help you.</p>"},{"location":"index.html#projects","title":"Projects","text":"<ul> <li>TelegramBotAPI</li> </ul>"},{"location":"krontab/describing/krontabscheduler.html","title":"KrontabScheduler","text":"<p><code>KronScheduler</code> is the simple interface with only one function <code>next</code>. This function optionally get as a parameter <code>DateTime</code> which will be used as start point for the calculation of next trigger time. This function will return the next <code>DateTime</code> when something must happen.</p>"},{"location":"krontab/describing/krontabscheduler.html#default-realisation","title":"Default realisation","text":"<p>Default realisation (<code>CronDateTimeScheduler</code>) can be created using several ways:</p> <ul> <li>Via <code>buildSchedule</code> (or <code>createSimpleScheduler</code>) functions with crontab-like syntax parameter</li> <li>Via <code>buildSchedule</code> (or <code>SchedulerBuilder</code> object), which using lambda to configure scheduler</li> </ul> <p>In the examples below the result of created scheduler will be the same.</p>"},{"location":"krontab/describing/krontabscheduler.html#crontab-like-way","title":"Crontab-like way","text":"<p>Crontab-like syntax</p> <p> See String format for more info about the crontab-line syntax</p> <p>This way will be very useful for cases when you need to configure something via external configuration (from file on startup or via some parameter from requests, for example):</p> <pre><code>val schedule = \"5 * * * *\"\nval scheduler = buildSchedule(schedule)\n\nscheduler.asFlow().onEach {\n  // this block will be called every minute at 5 seconds\n}.launchIn(someCoroutineScope)\n</code></pre>"},{"location":"krontab/describing/krontabscheduler.html#lambda-way","title":"Lambda way","text":"<p>In case of usage builder (lets call it <code>lambda way</code>), you will be able to configure scheduler in more type-safe way:</p> <pre><code>val scheduler = buildSchedule {\n  seconds {\n    at(5)\n  }\n}\n\nscheduler.asFlow().onEach {\n  // this block will be called every minute at 5 seconds\n}.launchIn(someCoroutineScope)\n</code></pre>"},{"location":"krontab/describing/krontabscheduler.html#custom-scheduler","title":"Custom scheduler","text":"<p>You are always able to use your own realisation of scheduler. For example:</p> <pre><code>class RandomScheduler : KronScheduler {\n  override suspend fun next(relatively: DateTime): DateTime {\n    return relatively + DateTimeSpan(seconds = Random.nextInt() % 60)\n  }\n}\n</code></pre> <p>In the example above we have created <code>RandomScheduler</code>, which will return random next time in range <code>0-60</code> seconds since <code>relatively</code> argument.</p>"},{"location":"krontab/describing/string-format.html","title":"String format","text":"<p>As in <code>crontab</code> util, this library have almost the same format of string:</p> Seconds Minutes Hours Days of months Months Years Timezone Offset Week days Milliseconds Range 0..59 0..59 0..23 0..30 0..11 Any <code>Int</code> Any <code>Int</code> 0..6 0..999 Suffix - - - - - - <code>o</code> <code>w</code> <code>ms</code> Optional \u274c \u274c \u274c \u274c \u274c \u2705 \u2705 \u2705 \u2705 Full syntax support \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u274c \u2705 \u2705 Position 0 1 2 3 4 Any after months Any after months Any after months Any after months Examples <code>0</code>, <code>*/15</code>, <code>30</code> <code>0</code>, <code>*/15</code>, <code>30</code> <code>0</code>, <code>*/15</code>, <code>22</code> <code>0</code>, <code>*/15</code>, <code>30</code> <code>0</code>, <code>*/5</code>, <code>11</code> <code>0</code>, <code>*/15</code>, <code>30</code> <code>60o</code> (UTC+1) <code>0w</code>, <code>*/2w</code>, <code>4w</code> <code>0ms</code>, <code>*/150ms</code>, <code>300ms</code> <p>Example with almost same description:</p> <pre><code>/-------------------- (0-59) \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 Seconds\n| /------------------ (0-59) \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 Minutes\n| | /---------------- (0-23) \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 Hours\n| | | /-------------- (0-30) \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 Days of months\n| | | | /------------ (0-11) \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 Months\n| | | | | /---------- (optional, any int) Year\n| | | | | | /-------- (optional) \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 Timezone offset\n| | | | | | |  /----- (optional, 0-6) \u00b7\u00b7\u00b7 Week days\n| | | | | | |  |  /-- (optional, 0-999) \u00b7 Milliseconds (0 by default)\n* * * * * * 0o *w 0ms\n</code></pre> <p>Years, timezone, week days and milliseconds are optional settings. Next snippets are equal:</p> <pre><code>*/15 * * * *\n*/15 * * * * * // with year\n*/15 * * * * * 0ms // with year and milliseconds\n</code></pre>"},{"location":"krontab/describing/string-format.html#supported-syntax","title":"Supported syntax","text":"<p>Currently the library support next syntax for date/time elements:</p> <ul> <li><code>{int}-{int}</code> - ranges</li> <li><code>{int}/{int}</code> - start/step</li> <li><code>*/{int}</code> - every {int}</li> <li><code>{int}</code> - just at the time</li> <li><code>{other_element},{other_element}</code> - listing</li> <li><code>F</code> or <code>f</code> - first possible value</li> <li><code>L</code> or <code>l</code> - last possible value (last day of month, for example)</li> </ul>"},{"location":"krontab/describing/string-format.html#ranges","title":"Ranges","text":"<p>Ranges are working like common <code>rangeTo</code> (or <code>..</code>) in kotlin:</p> <pre><code>0-5 * * * *\n</code></pre> <p>In the example above scheduler will trigger every second from the beginning of the minute up to fifth second of minute.</p>"},{"location":"krontab/describing/string-format.html#startstep","title":"Start/Step","text":"<p>Start/step is a little bit more complicated syntax. It means <code>start from the first element, repeat triggering every second element</code>. Examples:</p> <pre><code>5/15 * * * *\n</code></pre> <p>Means that each minute starting from fifth second it will repeat triggering every fifteenth second: <code>5, 20, 35, 50</code>.</p>"},{"location":"krontab/describing/string-format.html#every","title":"Every","text":"<p>Every is more simple syntax and could be explained as a shortcut for <code>0/{int}</code>. Example:</p> <pre><code>*/15 * * * *\n</code></pre> <p>Means that each minute it will repeat triggering every fifteenth second: <code>0, 15, 30, 45</code>.</p>"},{"location":"krontab/describing/string-format.html#just-at-the-time","title":"Just at the time","text":"<p>The most simple syntax. It means, that scheduler will call triggering every time when element was reached:</p> <pre><code>15 * * * *\n</code></pre> <p>Means that each minute scheduler will call triggering at the fifteenth second.</p>"},{"location":"krontab/describing/string-format.html#listing","title":"Listing","text":"<p>All the previous elements can be combined with listing. Lets just see several examples:</p> <pre><code>0,10 * * * *\n</code></pre> <p>Will trigger every minute at the <code>0</code> and <code>10</code> seconds (see Just at the time)</p> <pre><code>0-5,10 * * * *\n</code></pre> <p>Will trigger every minute from <code>0</code> to <code>5</code> seconds and at the <code>10</code> seconds (see Ranges)</p>"},{"location":"krontab/describing/string-format.html#examples","title":"Examples","text":"<ul> <li><code>0/5 * * * *</code> for every five seconds triggering</li> <li><code>0/5,L * * * *</code> for every five seconds triggering and on 59 second</li> <li><code>0/15 30 * * *</code> for every 15th seconds in a half of each hour</li> <li><code>0/15 30 * * * 500ms</code> for every 15th seconds in a half of each hour when milliseconds equal to 500</li> <li><code>1 2 3 F,4,L 5</code> for triggering in near first second of second minute of third hour of first, fifth and last days of may</li> <li><code>1 2 3 F,4,L 5 60o</code> for triggering in near first second of second minute of third hour of first, fifth and last days of may with timezone UTC+01:00</li> <li><code>1 2 3 F,4,L 5 60o 0-2w</code> for triggering in near first second of second minute of third hour of first, fifth and last days of may in case if it will be in Sunday-Tuesday week days with timezone UTC+01:00</li> <li><code>1 2 3 F,4,L 5 2021</code> for triggering in near first second of second minute of third hour of first, fifth and last days of may of 2021st year</li> <li><code>1 2 3 F,4,L 5 2021 60o</code> for triggering in near first second of second minute of third hour of first, fifth and last days of may of 2021st year with timezone UTC+01:00</li> <li><code>1 2 3 F,4,L 5 2021 60o 0-2w</code> for triggering in near first second of second minute of third hour of first, fifth and last days of may of 2021st year if it will be in Sunday-Tuesday week days with timezone UTC+01:00</li> <li><code>1 2 3 F,4,L 5 2021 60o 0-2w 500ms</code> for triggering in near first second of second minute of third hour of first, fifth and last days of may of 2021st year if it will be in Sunday-Tuesday week days with timezone UTC+01:00 when milliseconds will be equal to 500</li> </ul>"},{"location":"krontab/introduction/faq.html","title":"FAQ","text":""},{"location":"krontab/introduction/faq.html#how-oftern-new-versions-are-releasing","title":"How oftern new versions are releasing?","text":"<p>Not very often. It depend on libraries (coroutines, korlibs/klock) updates and on some new awesome, but lightweight, features coming.</p>"},{"location":"krontab/introduction/faq.html#where-this-library-could-be-useful","title":"Where this library could be useful?","text":"<p>First of all, this library will be useful for long uptime applications which have some tasks to do from time to time.</p>"},{"location":"krontab/introduction/faq.html#how-to-use-crontab-like-syntax","title":"How to use crontab-like syntax?","text":"<p>In two words, you should call <code>buildSchedule</code> or <code>createSimpleScheduler</code>:</p> <pre><code>buildSchedule(\"5 * * * *\").asFlow().collect { /* do something */ }\n</code></pre> <p>You can read more about syntax in String format section.</p>"},{"location":"krontab/introduction/how-to-use.html","title":"How to use","text":""},{"location":"krontab/introduction/how-to-use.html#previous-pages","title":"Previous pages","text":"<ul> <li>Including in project</li> </ul>"},{"location":"krontab/introduction/how-to-use.html#buildschedule","title":"<code>buildSchedule</code>","text":"<p>Custom KronScheduler</p> <p> You always able to create your own scheduler. In this section will be presented different ways and examples around standard <code>CronDateTimeScheduler</code> builders <code>buildSchedule</code>. You can read about schedulers in KrontabScheduler</p> <p>Currently, <code>buildSchedule</code> is the recommended start point for every scheduler. Usually, it is look like:</p> <pre><code>val scheduler = buildSchedule(\"5 * * * *\")\n</code></pre> <p>Or:</p> <pre><code>val scheduler = buildSchedule {\n  seconds {\n    at(5)\n  }\n}\n</code></pre> <p>On the top of any <code>KronScheduler</code> currently there are several groups of extensions:</p> <ul> <li>Executes</li> <li>Shortcuts</li> <li>Flows</li> </ul>"},{"location":"krontab/introduction/how-to-use.html#executes","title":"Executes","text":"<p>All executes are look like <code>do...</code>. All executes are described below:</p> <ul> <li><code>doOnce</code> - will get the next time for executing, delay until that time and call <code>block</code> with returning of the <code>block</code> result</li> <li><code>doWhile</code> - will call <code>doOnce</code> while it will return <code>true</code> (that means that <code>block</code> must return <code>true</code> if it expects that next call must happen). In two words: it will run while <code>block</code> returning <code>true</code></li> <li><code>doInfinity</code> - will call the <code>block</code> using <code>doWhile</code> with predefined returning <code>true</code>. In two words: it will call <code>block</code> while it do not throw error</li> </ul>"},{"location":"krontab/introduction/how-to-use.html#shortcuts","title":"Shortcuts","text":"<p>Shortcuts are the constants that are initializing in a lazy way to provide preset <code>KronScheduler</code>s. For more info about <code>KrontabScheduler</code> you can read its own page.</p> <ul> <li><code>AnyTimeScheduler</code> - will always return incoming <code>DateTime</code> as next</li> <li><code>Every*Scheduler</code> - return near * since the passed <code>relatively</code>:</li> <li><code>EverySecondScheduler</code></li> <li><code>EveryMinuteScheduler</code></li> <li><code>EveryHourScheduler</code></li> <li><code>EveryDayOfMonthScheduler</code></li> <li><code>EveryMonthScheduler</code></li> <li><code>EveryYearScheduler</code></li> </ul>"},{"location":"krontab/introduction/how-to-use.html#flows","title":"Flows","text":"<p>Here currently there is only one extension for <code>KronScheduler</code>: <code>KronScheduler#asFlow</code>. As a result you will get <code>Flow&lt;DateTime&gt;</code> (in fact <code>SchedulerFlow</code>) which will trigger next <code>emit</code> on each not null <code>next</code> <code>DateTime</code></p>"},{"location":"krontab/introduction/including-in-project.html","title":"Including in project","text":"<p>In two words, you must add dependency <code>dev.inmo:krontab:$krontab_version</code> to your project. The latest version presented by next badge:</p> <p></p>"},{"location":"krontab/introduction/including-in-project.html#notice-about-repository","title":"Notice about repository","text":"<p>To use this library, you will need to include <code>MavenCentral</code> repository in you project</p>"},{"location":"krontab/introduction/including-in-project.html#buildgradle","title":"build.gradle","text":"<pre><code>mavenCentral()\n</code></pre>"},{"location":"krontab/introduction/including-in-project.html#dependencies","title":"Dependencies","text":"<p>Next snippets must be placed into your <code>dependencies</code> part of <code>build.gradle</code> (for gradle) or <code>pom.xml</code> (for maven).</p>"},{"location":"krontab/introduction/including-in-project.html#gradle","title":"Gradle","text":"<pre><code>implementation \"dev.inmo:krontab:$krontab_version\"\n</code></pre>"},{"location":"krontab/introduction/including-in-project.html#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;dev.inmo&lt;/groupId&gt;\n    &lt;artifactId&gt;krontab&lt;/artifactId&gt;\n    &lt;version&gt;${krontab_version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"tgbotapi/dsls/keyboards.html","title":"Keyboards","text":"<p>In the telegram system there are two types of keyboards:</p> Reply Inline Keyboard for each user in the chat Keyboard linked to the certain message <p>Low-level way to create keyboard looks like in the next snippet:</p> <pre><code>ReplyKeyboardMarkup(\n    matrix {\n        row {\n            add(SimpleKeyboardButton(\"Simple text\"))\n            // ...\n        }\n        // ...\n    }\n)\n</code></pre> <p>In case you wish to create inline keyboard, it will look like the same as for reply keyboard. But there is another way. The next snippet will create the same keyboard as on the screenshots above:</p> <pre><code>// reply keyboard\nreplyKeyboard {\n    row {\n        simpleButton(\"7\")\n        simpleButton(\"8\")\n        simpleButton(\"9\")\n        simpleButton(\"*\")\n    }\n    row {\n        simpleButton(\"4\")\n        simpleButton(\"5\")\n        simpleButton(\"6\")\n        simpleButton(\"/\")\n    }\n    row {\n        simpleButton(\"1\")\n        simpleButton(\"2\")\n        simpleButton(\"3\")\n        simpleButton(\"-\")\n    }\n    row {\n        simpleButton(\"0\")\n        simpleButton(\".\")\n        simpleButton(\"=\")\n        simpleButton(\"+\")\n    }\n}\n\n// inline keyboard\ninlineKeyboard {\n    row {\n        dataButton(\"Get random music\", \"random\")\n    }\n    row {\n        urlButton(\"Send music to friends\", \"https://some.link\")\n    }\n}\n</code></pre>"},{"location":"tgbotapi/dsls/live-location.html","title":"Live Location","text":"<p>Bot API allows you to send live locations and update them during their lifetime. In this library there are several ways to use this API:</p> <ul> <li>Directly via API calls (sendLiveLocation and editLiveLocation)</li> <li>startLiveLocation</li> <li>handleLiveLocation</li> </ul>"},{"location":"tgbotapi/dsls/live-location.html#sendlivelocation","title":"sendLiveLocation","text":"<p>In the Bot API there is no independent <code>sendLiveLocation</code> method, instead it is suggested to use sendLocation with setting up <code>live_period</code>. In this library in difference with original Bot API live location is special request. It was required because of in fact live locations and static locations are different types of location info and you as bot developer may interact with them differently.</p> <p>Anyway, in common case the logic looks like:</p> <ul> <li>Send sendLiveLocation</li> <li>Use editLiveLocation to change it during its lifetime</li> <li>Use stopLiveLocation to abort it before lifetime end</li> </ul>"},{"location":"tgbotapi/dsls/live-location.html#startlivelocation","title":"startLiveLocation","text":"<p>In difference with sendLiveLocation, startLiveLocation using LiveLocationProvider. With this provider you need not to handle chat and message ids and keep some other data for location changes. Instead, you workflow with provider will be next:</p> <ul> <li>startLiveLocation</li> <li>Use LiveLocationProvider#updateLocation to update location and optionally add inline keyboard</li> <li>Use LiveLocationProvider#close to abort live location before its end</li> </ul> <p>Besides, <code>LiveLocationProvider</code> contains different useful parameters about live location</p>"},{"location":"tgbotapi/dsls/live-location.html#handlelivelocation","title":"handleLiveLocation","text":"<p>This way of live locations handling is based on coroutines Flow and allow you to pass some external <code>Flow</code> with EditLiveLocationInfo. So, workflow:</p> <ul> <li>Create your own flow of locations. For example:</li> </ul> <pre><code>flow {\n  var i = 0\n  while (isActive) {\n    val newInfo = EditLiveLocationInfo(\n      latitude = i.toDouble(),\n      longitude = i.toDouble(),\n      replyMarkup = flatInlineKeyboard {\n        dataButton(\"Cancel\", \"cancel\")\n      }\n    )\n    emit(newInfo)\n    i++\n    delay(10000L) // 10 seconds\n  }\n}\n</code></pre> <ul> <li>In case you needed, create your collector to store the message with live location:</li> </ul> <pre><code>val currentMessageState = MutableStateFlow&lt;ContentMessage&lt;LocationContent&gt;?&gt;(null)\n</code></pre> <ul> <li>Start handle live location. handleLiveLocation works synchronosly (in current coroutine) and will ends only when your flow will ends. Thats why there are two ways to call it:</li> </ul> <pre><code>handleLiveLocation(\n  it.chat.id,\n  locationsFlow,\n  sentMessageFlow = FlowCollector { currentMessageState.emit(it) }\n)\n// this code will be called after `locationsFlow` will ends\n</code></pre> <p>OR</p> <pre><code>scope.launch {\n  handleLiveLocation(\n    it.chat.id,\n    locationsFlow,\n    sentMessageFlow = FlowCollector { currentMessageState.emit(it) }\n  )\n}\n// this code will be called right after launch will be completed\n</code></pre> <p>See our example to get more detailed sample</p>"},{"location":"tgbotapi/dsls/text.html","title":"Text","text":"<p>For the text creating there are several tools. The most simple one is to concatenate several text sources to make list of text sources as a result:</p> <pre><code>val sources = \"Regular start of text \" + bold(\"with bold part\") + italic(\"and italic ending\")\n</code></pre> <p>But there is a little bit more useful way: entities builder:</p> <pre><code>val items = (0 until 10).map { it.toString() }\nbuildEntities(\" \") {// optional \" \" auto separator which will be pasted between text sources\n    +\"It is regular start too\" + bold(\"it is bold as well\")\n    items.forEachIndexed { i, item -&gt;\n        if (i % 2) {\n            italic(item)\n        } else {\n            strikethrough(item)\n        }\n    }\n}\n</code></pre> <p>In the code above we are creating an items list just for demonstrating that inside of buildEntities body we may use any operations for cunstructing our result list of <code>TextSource</code>s. As a result, will be created the list which will looks like in telegram as \u201cIt is regular start too it is bold as well 0 ~~1~~ 2 ~~3~~ 4 ~~5~~ 6 ~~7~~ 8 ~~9~~\u201d.</p>"},{"location":"tgbotapi/introduction/before-any-bot-project.html","title":"Before any bot project","text":"<p>There are several places you need to visit for starting work with any Telegram Bot framework on any language:</p> <ul> <li>Bots info introduction</li> <li>Telegram Bot API reference (you can skip it, but it could be useful to know some specific cases in Telegram Bot API)</li> </ul> <p>Anyway, the most important link is How do I create a bot? inside of Telegram Bot API</p>"},{"location":"tgbotapi/introduction/before-any-bot-project.html#next-steps","title":"Next steps","text":"<ul> <li>Including in your project</li> </ul>"},{"location":"tgbotapi/introduction/first-bot.html","title":"First bot","text":"<p>Examples info</p> <p> A lot of examples with using of Telegram Bot API you can find in this github repository</p>"},{"location":"tgbotapi/introduction/first-bot.html#the-most-simple-bot","title":"The most simple bot","text":"<p>The most simple bot will just print information about itself. All source code you can find in this repository. Our interest here will be concentrated on the next example part:</p> <pre><code>suspend fun main(vararg args: String) {\n  val botToken = args.first()\n  val bot = telegramBot(botToken)\n  println(bot.getMe())\n}\n</code></pre> <p>So, let\u2019s get understanding, about what is going on:</p> <ol> <li><code>suspend fun main(vararg args: String)</code>:<ul> <li><code>suspend</code> required for making of requests inside of this function. For more info you can open official documentation for coroutins. In fact, <code>suspend fun main</code> is the same that <code>fun main() = runBlocking {}</code> from examples</li> </ul> </li> <li><code>val botToken = args.first()</code>: here we are just getting the bot token from first arguments of command line</li> <li><code>val bot = telegramBot(botToken)</code> : inside of <code>bot</code> will be RequestsExecutor object which will be used for all requests in any project with this library</li> <li><code>println(bot.getMe())</code>: here happens calling of getMe extension</li> </ol> <p>As a result, we will see in the command line something like</p> <pre><code>ExtendedBot(id=ChatId(chatId=123456789), username=Username(username=@first_test_ee17e8_bot), firstName=Your bot name, lastName=, canJoinGroups=false, canReadAllGroupMessages=false, supportsInlineQueries=false)\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html","title":"Including in your project","text":"<p>There are three projects:</p> <ul> <li><code>TelegramBotAPI Core</code> - project with base for all working with Telegram Bot API</li> <li><code>TelegramBotAPI API Extensions</code> - extension of <code>TelegramBotAPI</code> with functions for more comfortable work with Telegram Bot API</li> <li><code>TelegramBotAPI Utils Extensions</code> - extension of <code>TelegramBotAPI</code> with functions for extending of different things like retrieving of updates</li> </ul> <p>TelegramBotAPI</p> <p>Also, there is an aggregator-version <code>tgbotapi</code>, which will automatically include all projects above. It is most recommended version due to the fact that it is including all necessary tools around <code>TelegramBotAPI Core</code>, but it is optionally due to the possible restrictions on the result methods count (for android) or bundle size</p> <p>Examples</p> <p>You can find full examples info in this repository. In this repository there full codes which are working in normal situation. Currently, there is only one exception when these examples could work incorrectly: you are living in the location where Telegram Bot API is unavailable. For solving this problem you can read Proxy setup part</p>"},{"location":"tgbotapi/introduction/including-in-your-project.html#notice-about-repository","title":"Notice about repository","text":"<p>To use this library, you will need to include <code>Maven Central</code> repository in your project</p>"},{"location":"tgbotapi/introduction/including-in-your-project.html#buildgradle","title":"build.gradle","text":"<pre><code>mavenCentral()\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#pomxml","title":"pom.xml","text":"<pre><code>&lt;repository&gt;\n  &lt;id&gt;central&lt;/id&gt;\n  &lt;name&gt;mavenCentral&lt;/name&gt;\n  &lt;url&gt;https://repo1.maven.org/maven2&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#dev-channel","title":"Dev channel","text":"<p>Besides, there is developer versions repo. To use it in your project, add the repo in <code>repositories</code> section:</p> Gradle <pre><code>maven {\n    url \"https://git.inmo.dev/api/packages/InsanusMokrassar/maven\"\n}\n</code></pre> Maven <pre><code>&lt;repository&gt;\n  &lt;id&gt;dev.inmo&lt;/id&gt;\n  &lt;name&gt;InmoDev&lt;/name&gt;\n  &lt;url&gt;https://git.inmo.dev/api/packages/InsanusMokrassar/maven&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#telegrambotapi","title":"TelegramBotAPI","text":"<p>As <code>tgbotapi_version</code> variable in next snippets will be used variable with next last published version:</p> <p></p>"},{"location":"tgbotapi/introduction/including-in-your-project.html#buildgradle_1","title":"build.gradle","text":"<pre><code>implementation \"dev.inmo:tgbotapi:$tgbotapi_version\"\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#pomxml_1","title":"pom.xml","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;dev.inmo&lt;/groupId&gt;\n    &lt;artifactId&gt;tgbotapi&lt;/artifactId&gt;\n    &lt;version&gt;${tgbotapi_version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#telegrambotapi-core","title":"TelegramBotAPI Core","text":"<p>As <code>tgbotapi_version</code> variable in next snippets will be used variable with next last published version:</p> <p></p>"},{"location":"tgbotapi/introduction/including-in-your-project.html#buildgradle_2","title":"build.gradle","text":"<pre><code>implementation \"dev.inmo:tgbotapi.core:$tgbotapi_version\"\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#pomxml_2","title":"pom.xml","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;dev.inmo&lt;/groupId&gt;\n    &lt;artifactId&gt;tgbotapi.core&lt;/artifactId&gt;\n    &lt;version&gt;${tgbotapi_version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#telegrambotapi-api-extensions","title":"TelegramBotAPI API Extensions","text":"<p>As <code>tgbotapi_version</code> variable in next snippets will be used variable with next last published version:</p> <p></p>"},{"location":"tgbotapi/introduction/including-in-your-project.html#buildgradle_3","title":"build.gradle","text":"<pre><code>implementation \"dev.inmo:tgbotapi.api:$tgbotapi_version\"\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#pomxml_3","title":"pom.xml","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;dev.inmo&lt;/groupId&gt;\n    &lt;artifactId&gt;tgbotapi.api&lt;/artifactId&gt;\n    &lt;version&gt;${tgbotapi_version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#telegrambotapi-utils-extensions","title":"TelegramBotAPI Utils Extensions","text":"<p>As <code>tgbotapi_version</code> variable in next snippets will be used variable with next last published version:</p> <p></p>"},{"location":"tgbotapi/introduction/including-in-your-project.html#buildgradle_4","title":"build.gradle","text":"<pre><code>implementation \"dev.inmo:tgbotapi.utils:$tgbotapi_version\"\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#pomxml_4","title":"pom.xml","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;dev.inmo&lt;/groupId&gt;\n    &lt;artifactId&gt;tgbotapi.utils&lt;/artifactId&gt;\n    &lt;version&gt;${tgbotapi_version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"tgbotapi/introduction/including-in-your-project.html#next-steps","title":"Next steps","text":"<ul> <li>Proxy setup</li> <li>First bot</li> </ul>"},{"location":"tgbotapi/introduction/proxy-setup.html","title":"Proxy setup","text":"<p>In some locations Telegram Bots API urls will be unavailable. In this case all examples will just throw exception like:</p> <pre><code>Exception in thread \"main\" java.net.ConnectException: Connection refused\n    at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)\n    at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:717)\n    at io.ktor.network.sockets.SocketImpl.connect$ktor_network(SocketImpl.kt:36)\n    at io.ktor.network.sockets.SocketImpl$connect$1.invokeSuspend(SocketImpl.kt)\n    at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n    at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:56)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:571)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:738)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:678)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:665)\n\nProcess finished with exit code 1\n</code></pre> <p>There are several ways to solve this problem:</p> <ul> <li>Built-in proxy config (will require some socks or http proxy server)</li> <li>System-configured VPN or proxy</li> <li>Your own Bot API Server</li> </ul>"},{"location":"tgbotapi/introduction/proxy-setup.html#using-ktor-client-built-in-proxy","title":"Using Ktor Client built-in proxy","text":"<p>First of all, you will need to use one more library:</p> <p>build.gradle:</p> <pre><code>implementation \"io.ktor:ktor-client-okhttp:2.0.1\"\n</code></pre> <p>Dependency note</p> <p> In the snippet above was used version <code>2.0.1</code> which is actual for <code>TelegramBotAPI</code> at the moment of filling this documentation (<code>May 22 2022</code>, <code>TelegramBotAPI</code> version <code>2.0.0</code>) and you can update version of this dependency in case if it is outdated.</p> <p>For configuring proxy for your bot inside your program, you can use next snippet:</p> <pre><code>val botToken = \"HERE MUST BE YOUR TOKEN\"\nval bot = telegramBot(botToken) {\n  ktorClientEngineFactory = OkHttp\n  proxy = ProxyBuilder.socks(\"127.0.0.1\", 1080)\n}\n</code></pre> <p>Explanation line by line:</p> <ol> <li><code>val botToken = \"HERE MUST BE YOUR TOKEN\"</code> - here we are just creating variable <code>botToken</code></li> <li><code>val bot = telegramBot(botToken) {</code> - start creating bot</li> <li><code>ktorClientEngineFactory = OkHttp</code> - setting up engine factory of our bot. On the time of documentation filling, <code>OkHttp</code> is one of the engines in <code>Ktor</code> system which supports socks proxy. More you can read on Ktor site in subparts about engines and proxy</li> <li><code>proxy = ProxyBuilder.socks(\"127.0.0.1\", 1080)</code> - here we are setting up our proxy. Here was used local server which (as assumed) will connect to server like <code>shadowsocks</code></li> </ol>"},{"location":"tgbotapi/introduction/proxy-setup.html#next-steps","title":"Next steps","text":"<ul> <li>First bot</li> </ul>"},{"location":"tgbotapi/logic/api-extensions.html","title":"API Extensions","text":"<p>API extensions is a module which you may include in your project in addition to core part. In most cases this module will allow just use syntax like <code>bot.getUpdates()</code> instead of <code>bot.execute(GetUpdates())</code>, but there are several other things you will achieve with that syntax.</p>"},{"location":"tgbotapi/logic/api-extensions.html#bot-builder","title":"Bot builder","text":"<p>This functionality allow you to build bot in more unified and comfortable way than standard creating with <code>telegramBot</code> function</p> <pre><code>buildBot(\n    \"TOKEN\"\n) {\n  proxy = ProxyBuilder.socks(host = \"127.0.0.1\", port = 4001) // just an example, more info on https://ktor.io/docs/proxy.html\n  ktorClientConfig = {\n    // configuring of ktor client\n  }\n  ktorClientEngineFactory = {\n   // configuring of ktor client engine \n  }\n}\n</code></pre>"},{"location":"tgbotapi/logic/api-extensions.html#downloading-of-files","title":"Downloading of files","text":"<p>In standard library requests there are no way to download some file retrieved in updates or after requests. You may use syntax like <code>bot.downloadFile(file)</code> where <code>file</code> is <code>TelegramMediaFile</code> from telegram, <code>FileId</code> or even <code>PathedFile</code> from GetFile request (sources).</p>"},{"location":"tgbotapi/logic/api-extensions.html#live-location","title":"Live location","text":"<p>By default, you should handle updates of Live location by your code. But with extension bot#startLiveLocation you may provide all necessary startup parameters and handle updates with just calling <code>updateLocation</code> for retrieved LiveLocationProvider.</p>"},{"location":"tgbotapi/logic/api-extensions.html#what-is-next","title":"What is next?","text":"<p>There are several things you may read next:</p> <ul> <li>Updates retrieving</li> <li>Read about second level of working with library</li> <li>Read about BehaviourBuilder</li> </ul>"},{"location":"tgbotapi/logic/behaviour-builder-with-fsm.html","title":"Behaviour Builder with FSM","text":"<p>Behaviour builder with FSM is based on the MicroUtils FSM. There are several important things in FSM:</p> <ul> <li><code>State</code> - any object which implements State interface</li> <li><code>StateHandler</code> (or CheckableHandlerHolder) - the handler of states</li> <li>StatesMachine - some machine which work with states and handlers</li> <li>StatesManager - simple manager that will solve which states to save and notify about states changes via its flows</li> </ul> <p><code>StatesMachine</code> have two methods:</p> <ul> <li><code>start</code> which will start work of machine</li> <li><code>startChain</code> which will add new state for handling</li> </ul> <p>The most based way to create <code>StatesMachine</code> and register <code>StateHandler</code>s looks like in the next snippet:</p> <pre><code>buildFSM&lt;TrafficLightState&gt; {\n    strictlyOn&lt;SomeState&gt; {\n        // state handling\n    }\n}.start(CoroutineScope(...)).join()\n</code></pre> <p>Full example</p> <p> You may find full example of FSM usage in the tests of FSM in MicroUtils</p> <p>So, you must do next steps before you will launch your bot with FSM:</p> <ul> <li>Create your states. Remember that you may plan to save them, so it is likely you will need to serialize it there</li> <li>Create your handlers for your states. In most cases it is useful to use CheckableHandlerHolder if you want to use standard states machine</li> <li>Solve which states managers to use (the most simple one is the DefaultStatesManager with InMemoryDefaultStatesManager)</li> </ul>"},{"location":"tgbotapi/logic/behaviour-builder-with-fsm.html#bot-with-fsm","title":"Bot with FSM","text":"<p>There are several extensions for <code>TelegramBot</code> to create your bot with FSM:</p> <ul> <li>buildBehaviourWithFSM<ul> <li>buildBehaviourWithFSMAndStartLongPolling</li> </ul> </li> <li>telegramBotWithBehaviourAndFSM<ul> <li>telegramBotWithBehaviourAndFSMAndStartLongPolling </li> </ul> </li> </ul> <p>All of them will take as an callback some object with type CustomBehaviourContextReceiver and will looks like in the next snippet:</p> <pre><code>telegramBotWithBehaviourAndFSMAndStartLongPolling&lt;YourStateType&gt;(\"BOT_TOKEN\") {\n    // here you may use any operations from BehaviourBuilder\n    // here you may use any operations from BehaviourContextWithFSMBuilder like strictlyOn and others\n}\n</code></pre>"},{"location":"tgbotapi/logic/behaviour-builder-with-fsm.html#examples","title":"Examples","text":"<ul> <li>TelegramBotAPI-examples/FSMBot</li> <li>MicroUtils simple example in the tests</li> </ul>"},{"location":"tgbotapi/logic/behaviour-builder.html","title":"Behaviour Builder","text":"<p>In the previous pages about updates handling and was mentioned that currently in the most cases you should use Flows. So, there is an improvement for that system which hide direct work with flows and allow you to create more declarative logic of your bot.</p>"},{"location":"tgbotapi/logic/behaviour-builder.html#main-parts-of-behaviour-builder","title":"Main parts of Behaviour Builder","text":"<p>There are several things you should know for better understanding of behaviour builder:</p> <ul> <li>BehaviourContext - it is the thing which contains all necessary tools for working with bots</li> <li>Triggers - <code>on*</code> extensions for <code>BehaviourContext</code> which allow you to create reaction on some update</li> <li>Expectations (or waiters) - <code>wait*</code> extensions which you may use in buildBehaviour function, but it is recommended to use it in bodies of triggers</li> </ul>"},{"location":"tgbotapi/logic/behaviour-builder.html#initialization","title":"Initialization","text":"<p>As was said above, there is buildBehaviour function which allow you set up your bot logic. Let\u2019s see an example:</p> <pre><code>val bot = telegramBot(\"TOKEN\")\n\nbot.buildBehaviour {\n  onCommand(\"start\") { // creating of trigger\n    val message = it\n    val content = message.content\n\n    reply(message, \"Ok, send me one photo\") // send text message with replying on incoming message\n\n    val photoContent = waitPhoto().first() // waitPhoto will return List, so, get first element\n\n    val photo = downloadFile(photoContent) // ByteArray of photo\n\n    // some logic with saving of photos\n  }\n}\n</code></pre>"},{"location":"tgbotapi/logic/behaviour-builder.html#filters","title":"Filters","text":"<p>In most cases there are opportunity to filter some of messages before starting of main logic. Let\u2019s look at this using the example above:</p> <pre><code>val bot = telegramBot(\"TOKEN\")\n\nbot.buildBehaviour {\n  onCommand(\n    \"start\",\n    initialFilter = {\n      it.content.textSources.size == 1 // make sure that user has sent /start without any additions\n    }\n  ) {\n    // ...\n  }\n}\n</code></pre> <p>OR</p> <pre><code>val bot = telegramBot(\"TOKEN\")\n\nbot.buildBehaviour {\n  onCommand(\n    \"start\",\n    requireOnlyCommandInMessage = true // it is default, but you can overwrite it with `requireOnlyCommandInMessage = false`\n  ) {\n    // ...\n  }\n}\n</code></pre>"},{"location":"tgbotapi/logic/exceptions-handling.html","title":"Exceptions handling","text":"<p>Unfortunatelly, exceptions handling in this library is a bit difficult in some places, but that have at least two reasons: flexibility and usability.</p>"},{"location":"tgbotapi/logic/exceptions-handling.html#in-place-handling","title":"\u201cIn place\u201d handling","text":"<p>In case you know, where exceptions are happening, you may use several tools for exceptions catching:</p> <ul> <li>Catching with result</li> <li>Catching with callback</li> </ul>"},{"location":"tgbotapi/logic/exceptions-handling.html#catching-with-result","title":"Catching with result","text":"<p>If you prefer to receive <code>Result</code> objects instead of some weird callbacks, you may use the next syntax:</p> <pre><code>safelyWithResult {\n    // do something\n}.onSuccess { // will be called if everything is right\n    // handle success\n}.onFailure { // will be called if something went wrong\n    // handle error\n    it.printStackTrace()\n}.getOrThrow() // will return value or throw exception\n</code></pre>"},{"location":"tgbotapi/logic/exceptions-handling.html#catching-with-callback","title":"Catching with callback","text":"<p>Also there is more simple (in some cases) way to handle exceptions with callbacks:</p> <pre><code>safely(\n  {\n      // handle error\n      it.printStackTrace()\n      null // return value\n  }\n) {\n    // do something\n}\n</code></pre>"},{"location":"tgbotapi/logic/exceptions-handling.html#bonus-different-types-of-handling","title":"Bonus: different types of handling","text":"<p>There are two types of handling:</p> <ul> <li>Just safely - when you are using something to obviously retrieve value or throw exception. When handling callback has been skipped, it will throw exception by default. For example:</li> </ul> <pre><code>safely(\n    {\n        it.printStackTrace()\n        \"error\"\n    }\n) {\n    error(\"Hi :)\") // emulate exception throwing\n    \"ok\"\n} // result will be with type String\n</code></pre> <ul> <li>Safely without exceptions - almost the same as <code>safely</code>, but this type by default allow to return nullable value (when exception was thrown) instead of just throwing (as with <code>safely</code>):</li> </ul> <pre><code>safelyWithouExceptions {\n    // do something\n} // will returns nullable result type\n</code></pre>"},{"location":"tgbotapi/logic/exceptions-handling.html#global-exceptions-handling","title":"Global exceptions handling","text":"<p>The most simple way to configure exceptions handling is to change <code>CoroutineContext</code> when you are creating your <code>CoroutineScope</code> for bot processing:</p> <pre><code>val bot = telegramBot(\"TOKEN\")\n\nbot.buildBehaviour (\n    scope = scope,\n    defaultExceptionsHandler = {\n        it.printStackTrace()\n    }\n) {\n    // ...\n}\n</code></pre> <p>OR</p> <pre><code>val bot = telegramBotWithBehaviour (\n    \"TOKEN\",\n    scope = scope,\n    defaultExceptionsHandler = {\n        it.printStackTrace()\n    }\n) {\n    // ...\n}\n</code></pre> <p>Here we have used <code>ContextSafelyExceptionHandler</code> class. It will pass default handling of exceptions and will call the block in most cases when something inside of your bot logic has thrown exception.</p>"},{"location":"tgbotapi/logic/files-handling.html","title":"Files handling","text":"<p>According to the documentation there are several ways to work with files:</p> <ul> <li>By FileId</li> <li>By FileUrl (<code>typealias</code> for the <code>FileId</code>)</li> <li>By some MultipartFile (in Telegram Bot API it is multipart requests)</li> </ul>"},{"location":"tgbotapi/logic/files-handling.html#files-receiving","title":"Files receiving","text":"<p>There are several cases you may need in your app to work with files:</p> <ul> <li>Save <code>FileId</code> (for sending in future)</li> <li>Download some file into memory/file in filesystem</li> </ul>"},{"location":"tgbotapi/logic/files-handling.html#where-to-get-file-id-or-url","title":"Where to get File id or url?","text":"<p>The most simple way to send some file is to get file id and send it. You may get file id from any message with media. For example, if you have received some Message, you may use asCommonMessage conversation to be able to get its <code>content</code> and then convert it to some content with media. Full code here:</p> <pre><code>val message: Message;\n\nval fileId = message.asCommonMessage() ?.withContent&lt;MediaContent&gt;() ?.content ?.media ?.fileId;\n</code></pre> <p>WAT? O.o</p> <p>In the code above we get some message, safely converted it to <code>CommonMessage</code> with <code>asCommonMessage</code>, then safely took its content via <code>withContent&lt;MediaContent&gt;() ?.content</code> and then just get its media file id.</p>"},{"location":"tgbotapi/logic/files-handling.html#download-files","title":"Download files","text":"<p>There are three ways to download files:</p> <ul> <li>Download it in memory as <code>ByteArray</code></li> <li>Take <code>ByteReadChannelAllocator</code> which allow to retrieve ByteReadChannel and do whatever you want with it</li> <li><code>[JVM Only]</code> Download it directly to file or temporal file</li> </ul>"},{"location":"tgbotapi/logic/files-handling.html#downloading-with-api-extensions","title":"Downloading with <code>API</code> extensions","text":""},{"location":"tgbotapi/logic/files-handling.html#files-jvmandroid","title":"Files (JVM/Android)","text":"<pre><code>val bot: TelegramBot;\nval fileId: FileId;\nval outputFile: File;\n\nbot.downloadFile(fileId, outputFile)\n</code></pre> <p>See downloadFile extension docs in the JVM tab to get more available options</p> <p>There is also way with saving of data into temporal file. That will allow you to do with data whatever you want without high requirements to memory or network connection:</p> <pre><code>val bot: TelegramBot;\nval fileId: FileId;\n\nval tempFile: File = bot.downloadFileToTemp(fileId)\n</code></pre> <p>See downloadFileToTemp extension docs to get more available options</p>"},{"location":"tgbotapi/logic/files-handling.html#byte-read-channel","title":"Byte read channel","text":"<pre><code>val bot: TelegramBot;\nval fileId: FileId;\n\nval bytes: ByteReadChannelAllocator = bot.downloadFileStream(fileId)\n</code></pre> <p>See downloadFileStream extension docs to get more available options</p>"},{"location":"tgbotapi/logic/files-handling.html#byte-read-channel-allocator","title":"Byte read channel allocator","text":"<pre><code>val bot: TelegramBot;\nval fileId: FileId;\n\nval bytes: ByteReadChannelAllocator = bot.downloadFileStreamAllocator(fileId)\n</code></pre> <p>See downloadFileStreamAllocator extension docs to get more available options</p>"},{"location":"tgbotapi/logic/files-handling.html#byte-arrays","title":"Byte arrays","text":"<pre><code>val bot: TelegramBot;\nval fileId: FileId;\n\nval bytes: ByteArray = bot.downloadFile(fileId)\n</code></pre> <p>See downloadFile extension docs to get more available options</p>"},{"location":"tgbotapi/logic/files-handling.html#low-level-or-how-does-it-work","title":"Low level or <code>how does it work?</code>","text":"<p>You may download file with streams or with downloading into the memory first. On low level you should do several things. They are presented in next snippet:</p> <pre><code>val bot: TelegramBot;\nval fileId: FileId;\n\nval pathedFile: PathedFile = bot.execute(GetFile(fileId))\n\nval downloadedBytes: ByteArray = bot.execute(DownloadFile(pathedFile.filePath))\n</code></pre> <p>In the snippet above we are getting file <code>PathedFile</code> by its <code>FileId</code> and use it to download file bytes into memory using <code>DownloadFile</code> request.</p> <p>You may use almost the same way but with byte read channel allocator:</p> <pre><code>val bot: TelegramBot;\nval fileId: FileId;\n\nval pathedFile: PathedFile = bot.execute(GetFile(fileId))\n\nval channelAllocator: ByteReadChannelAllocator = bot.execute(DownloadFileStream(pathedFile.filePath))\n\nval byteReadChannel: ByteReadChannel = channelAllocator()\n</code></pre> <p>And then you may look into ByteReadChannel docs to get more info about what you can do with that.</p> <p>Several useful links</p> <ul> <li>GetFile</li> <li>PathedFile</li> <li>DownloadFile</li> <li>DownloadFileStream</li> </ul>"},{"location":"tgbotapi/logic/files-handling.html#files-sending","title":"Files sending","text":"<p>Of course, in most cases you must be sure that file have correct type.</p>"},{"location":"tgbotapi/logic/files-handling.html#fileid-and-fileurl","title":"FileId and FileUrl","text":"<p>It is the most simple way to send any media in Telegram, but this way have several restrictions:</p> <ul> <li>The <code>FileId</code> which has retrieved for file should not (and probably will not too) equal to the <code>FileId</code> retrieved by some other bot</li> <li>There is a chance that the file id you are using will be expired with time</li> </ul>"},{"location":"tgbotapi/logic/files-handling.html#sending-via-file","title":"Sending via file","text":"<p>JS Restrictions</p> <p> Sending via file is accessible from all supported platforms, but there is small note about <code>JS</code> - due to restrictions of work with streams and stream-like data (<code>JS</code> have no native support of files streaming) on this platform all the files will be loaded inside of RAM before the sending to the telegram services.</p> <p>Sending via file is available throw the MultipartFile. There are several wayt to get it:</p> <ul> <li>Simple creating via its constructor: <code>MultipartFile(\"filename.jpg\") { /* here Input allocation */ }</code></li> <li>Via asMultiparFile extension applicable to any <code>ByteArray</code>, <code>ByteReadChannel</code>, <code>ByteReadChannelAllocator</code> or <code>File</code> (on any platform)</li> </ul> <p>In most cases, sending via files looks like in the next snippet:</p> <pre><code>val file: File;\n\nbot.sendDocument(chatId, file.asMultipartFile())\n</code></pre>"},{"location":"tgbotapi/logic/low-level-work-with-bots.html","title":"Low-level work with bots","text":"<p>The base version of library was done a lot of time ago and just got several additions related to improvements, updates in Telegram Bot API or some requests from our community.</p>"},{"location":"tgbotapi/logic/low-level-work-with-bots.html#base-things","title":"Base things","text":"<p>There are several important things in context of this library:</p> <ul> <li>RequestsExecutor (also \u201cknown\u201d as <code>TelegramBot</code>)</li> <li>Types</li> <li>Requests</li> </ul> <p>So, in most cases all your request calls with simplified api of this library (like <code>bot.getMe()</code>) will looks like <code>bot.execute(GetMe)</code>. Result of these calls is defined in type of any request (for example, for GetMe request the result type is ExtendedBot). As a result, you can avoid any extension api (like special API extensions) and use low level request with full controlling of the whole logic flow.</p>"},{"location":"tgbotapi/logic/low-level-work-with-bots.html#how-to-handle-updates","title":"How to handle updates","text":"<p>As was written above, it will require some request:</p> <pre><code>val updates = bot.execute(GetUpdates())\n</code></pre> <p>Result type of GetUpdates request is Update. You may find inheritors of this interface in Update kdocs.</p>"},{"location":"tgbotapi/logic/low-level-work-with-bots.html#what-is-next","title":"What is next?","text":"<p>As was said above, you may look into our API extensions in case you wish to use more high-level functions instead of <code>bot.execute(SomeRequest())</code>. Besides, it will be very useful to know more about updates retrieving.</p>"},{"location":"tgbotapi/logic/media-groups.html","title":"Media Groups","text":"<p>As you know, Telegram have the feature named Media Groups. Media groups have several differences with the common messages:</p> <ul> <li>Each media group message contains special media group id</li> <li>Media group may have special caption which will be visible if only the first message of media group contains caption</li> <li>In most cases media groups came with long polling/webhooks in one pack</li> <li>Media groups can be one of three types:<ul> <li>Visual (image/video)</li> <li>Documents</li> <li>Playlists (audio)</li> </ul> </li> </ul>"},{"location":"tgbotapi/logic/media-groups.html#specific-of-media-groups-in-libraries","title":"Specific of media groups in libraries","text":"<p>Row updates</p> <p> In tgbotapi there is no any additional handling of media groups by default and in case you will use simple bot.getUpdates, you will get the list of row updates and media groups will be included in this list as separated messages with MediaGroupPartContent. In that case you may use convertWithMediaGroupUpdates to be able to work with media groups as will be described below</p> <p>In case you are using standard long polling (one of alternatives is telegramBotWithBehaviourAndLongPolling) or webhooks updates will be converted uner the hood and as a result, you will take media groups as a content in one message:</p> <pre><code>telegramBotWithBehaviourAndLongPolling(\n  \"token\"\n) {\n  onVisualGallery { // it: CommonMessage&lt;MediaGroupContent&lt;VisualMediaGroupPartContent&gt;&gt;\n    it.content // MediaGroupContent&lt;VisualMediaGroupPartContent&gt;\n    it.content.group // List&lt;MediaGroupCollectionContent.PartWrapper&lt;VisualMediaGroupPartContent&gt;&gt;\n    it.content.group.forEach { // it: MediaGroupCollectionContent.PartWrapper&lt;VisualMediaGroupPartContent&gt;\n      it.messageId // source message id for current media group part\n      it.sourceMessage // source message for current media group part\n      it.content // VisualMediaGroupPartContent\n      println(it.content) // will print current content part info\n    }\n  }\n}\n</code></pre> <p>KDocs:</p> <ul> <li>onVisualGallery</li> <li>MediaGroupContent</li> <li>VisualMediaGroupPartContent</li> <li>MediaGroupCollectionContent.PartWrapper</li> </ul> <p>In two words, in difference with row Telegram Bot API, you will take media groups in one message instead of messages list.</p>"},{"location":"tgbotapi/logic/types-conversations.html","title":"Types conversations","text":"<p>One of the most important topics in context of tgbotapi is types conversations. This library is very strong-typed and a lot of things are based on types hierarchy. Lets look into the hierarchy of classes for the Message in 0.35.8: </p> <p>As you may see, it is a little bit complex and require several tools for types conversation.</p>"},{"location":"tgbotapi/logic/types-conversations.html#as","title":"As","text":"<p><code>as</code> conversations will return new type in case if it is possible. For example, when you got <code>Message</code>, you may use <code>asContentMessage</code> conversation to get message with <code>content</code>:</p> <pre><code>val message: Message;\nprintln(message.asContentMessage() ?.content)\n</code></pre> <p>This code will print <code>null</code> in case when <code>message</code> is not <code>ContentMessage</code>, and <code>content</code> when is.</p>"},{"location":"tgbotapi/logic/types-conversations.html#require","title":"Require","text":"<p><code>require</code> works like <code>as</code>, but instead of returning nullable type, it will always return object with required type OR throw <code>ClassCastException</code>:</p> <pre><code>val message: Message;\nprintln(message.requireContentMessage().content)\n</code></pre> <p>This code will throw exception when message is not <code>ContentMessage</code> and print <code>content</code> when is.</p>"},{"location":"tgbotapi/logic/types-conversations.html#when","title":"When","text":"<p><code>when</code> extensions will call passed <code>block</code> when type is correct. For example:</p> <pre><code>val message: Message;\nmessage.whenContentMessage {\n    println(it.content)\n}\n</code></pre> <p>Code placed above will print <code>content</code> when <code>message</code> is <code>ContentMessage</code> and do nothing when not</p>"},{"location":"tgbotapi/logic/updates-with-flows.html","title":"Updates with flows","text":"<p>Of course, in most cases here we will look up the way of using utils extnsions, but you may read deeper about updates retrieving here.</p>"},{"location":"tgbotapi/logic/updates-with-flows.html#phylosophy-of-flow-updates-retrieving","title":"Phylosophy of <code>Flow</code> updates retrieving","text":"<p>In most updates retrieving processes there are two components: UpdatesFiler and its inheritor FlowsUpdatesFilter. It is assumed, that you will do several things in your app to handle updates:</p> <ul> <li>Create your <code>UpdatesFilter</code> (for example, with flowsUpdatesFilter factory)</li> <li>Set it up (in case of <code>flowsUpdatesFilter</code> you will set up updates handling in the lambda passed to this factory)</li> <li>Provide updates to this filter with filter#asUpdateReceiver object</li> </ul> <p>Let\u2019s look how it works with the factory above:</p> <pre><code>// Step 1 - create filter\nval filter = flowsUpdatesFilter {\n  // Step 2 - set up handling. In this case we will print any message from group or user in console\n  messageFlow.onEach {\n    println(it)\n  }.launchIn(someCoroutineScope)\n}\n\n// Step 3 - passing updates to filter\nbot.getUpdates().forEach {\n  filter.asUpdatesReceiver(it)\n}\n</code></pre>"},{"location":"tgbotapi/logic/updates-with-flows.html#long-polling","title":"Long polling","text":"<p>Some example with long polling has been described above. But it is more useful to use some factories for it. In this page we will look for simple variant with TelegramBot#longPolling. So, with this function, your handling of updates will looks like:</p> <pre><code>val bot = telegramBot(\"TOKEN\")\n\nbot.longPolling {\n  messageFlow.onEach {\n    println(it)\n  }.launchIn(someCoroutineScope)\n}.join()\n</code></pre> <p>This example looks like the example above with three steps, but there are several important things here:</p> <ul> <li>You do not manage retrieving of updates by hands</li> <li><code>.join()</code> will suspend your function \ud83d\ude0a <code>longPolling</code> function returns <code>Job</code> and you may use it to:</li> <li><code>cancel</code> working of long polling (just call <code>job.cancel()</code>)</li> <li><code>join</code> and wait while the work of <code>longPolling</code> will not be completed (it will works infinity if you will not cancel it anywhere)</li> <li>FlowsUpdatesFilter has been created under the hood of <code>longPolling</code> function</li> </ul>"},{"location":"tgbotapi/logic/updates-with-flows.html#results-and-what-is-next","title":"Results and <code>What is next?</code>","text":"<p>As a result you can start listen updates and react on it. Next recommended articles:</p> <ul> <li>Behaviour Builder as a variant of asynchronous handling of your bot logic</li> <li>FSM variant of Behaviour Builder</li> </ul>"},{"location":"tgbotapi/updates/heroku.html","title":"Heroku","text":"<p>Preview reading</p> <p>It is recommended to visit our pages about UpdatesFilters and Webhooks to have more clear understanding about what is happening in this examples page</p> <p>Heroku is a popular place for bots hosting. In common case you will need to configure webhooks for your server to include getting updates without problems. There are several things related to heroku you should know:</p> <ul> <li>Heroku apps by default accessible via <code>https://&lt;app name&gt;.herokuapp.com/</code></li> <li>Heroku provide one port to be proxied for the link above. You can retrieve number of this port by calling <code>System.getenv(\"PORT\").toInt()</code></li> <li>Currently (<code>Sat Aug 15 5:04:21 +00 2020</code>) there is only one official server engine for ktor which is correctly working with Heroku: Tomcat server engine</li> </ul> <p>Server configuration alternatives</p> <p> Here will be presented variants of configuration of webhooks and starting server. You always able to set webhook manualy, create your own ktor server and include webhooks handling in it or create and start server with only webhooks handling. More info you can get on page Webhooks</p>"},{"location":"tgbotapi/updates/heroku.html#short-example-with-behaviour-builder","title":"Short example with Behaviour Builder","text":"<pre><code>suspend fun main {\n    // This subroute will be used as random webhook subroute to improve security according to the recommendations of Telegram\n    val subroute = uuid4().toString()\n    // Input/Output coroutines scope more info here: https://kotlinlang.org/docs/coroutines-guide.html\n    val scope = CoroutineScope(Dispatchers.IO)\n    // Here will be automatically created bot and available inside of lambda where you will setup your bot behaviour\n    telegramBotWithBehaviour(\n        // Pass TOKEN inside of your application environment variables\n        System.getenv(\"TOKEN\"),\n        scope = scope\n    ) {\n        // Set up webhooks and start to listen them\n        setWebhookInfoAndStartListenWebhooks(\n            // Automatic env which will be passed by heroku to the app\n            System.getenv(\"PORT\").toInt(),\n            // Server engine. More info here: https://ktor.io/docs/engines.html\n            Tomcat,\n            // Pass URL environment variable via settings of application. It must looks like https://&lt;app name&gt;.herokuapp.com\n            SetWebhook(\"${System.getenv(\"URL\").removeSuffix(\"/\")}/$subroute\"),\n            // Just callback which will be called when exceptions will happen inside of webhooks\n            {\n                it.printStackTrace()\n            },\n            // Set up listen requests from outside\n            \"0.0.0.0\",\n            // Set up subroute to listen webhooks to\n            subroute,\n            // BehaviourContext is the CoroutineScope and it is recommended to pass it inside of webhooks server\n            scope = this,\n            // BehaviourContext is the FlowsUpdatesFilter and it is recommended to pass its asUpdateReceiver as a block to retrieve all the updates\n            block = asUpdateReceiver\n        )\n        // Test reaction on each command with reply and text `Got it`\n        onUnhandledCommand {\n            reply(it, \"Got it\")\n        }\n    }\n    // Just potentially infinite await of bot completion\n    scope.coroutineContext.job.join()\n}\n</code></pre>"},{"location":"tgbotapi/updates/heroku.html#configuration-example-without-behaviour-builder","title":"Configuration example without Behaviour Builder","text":"<pre><code>// This subroute will be used as random webhook subroute to improve security according to the recommendations of Telegram\nval subroute = uuid4().toString()\nval bot = telegramBot(TOKEN)\nval scope = CoroutineScope(Dispatchers.Default)\n\nval filter = flowsUpdatesFilter {\n  messageFlow.onEach {\n    println(it) // will be printed \n  }.launchIn(scope)\n}\n\nval subroute = UUID.randomUUID().toString() // It will be used as subpath for security target as recommended by https://core.telegram.org/bots/api#setwebhook\n\nval server = bot.setWebhookInfoAndStartListenWebhooks(\n  // Automatic env which will be passed by heroku to the app\n  System.getenv(\"PORT\").toInt(),\n  // Server engine. More info here: https://ktor.io/docs/engines.html\n  Tomcat,\n  // Pass URL environment variable via settings of application. It must looks like https://&lt;app name&gt;.herokuapp.com\n  SetWebhook(\"${System.getenv(\"URL\").removeSuffix(\"/\")}/$subroute\"),\n  // Just callback which will be called when exceptions will happen inside of webhooks\n  {\n    it.printStackTrace()\n  },\n  // Set up listen requests from outside\n  \"0.0.0.0\",\n  // Set up subroute to listen webhooks to\n  subroute,\n  scope = scope,\n  block = filter.asUpdateReceiver\n)\n\nserver.environment.connectors.forEach {\n  println(it)\n}\nserver.start(false)\n</code></pre>"},{"location":"tgbotapi/updates/long-polling.html","title":"Long polling","text":"<p>Long polling is a technology of getting updates for cases you do not have some dedicated server or you have no opportunity to receive updates via webhooks. More about this you can read in wiki.</p>"},{"location":"tgbotapi/updates/long-polling.html#related-topics","title":"Related topics","text":"<ul> <li>Updates filters</li> </ul>"},{"location":"tgbotapi/updates/long-polling.html#long-polling-in-this-library","title":"Long polling in this library","text":"<p>There are a lot of ways to include work with long polling:</p> <ul> <li><code>RequestsExecutor#longPollingFlow</code> Is the base way to get all updates cold Flow. Remember, that this flow will not be launched automatically<ul> <li><code>RequestsExecutor#startGettingOfUpdatesByLongPolling</code> Old and almost deprecated way</li> <li><code>RequestsExecutor#longPolling</code> Works like <code>startGettingOfUpdatesByLongPolling</code> but shorted in a name :)</li> </ul> </li> <li><code>RequestsExecutor#createAccumulatedUpdatesRetrieverFlow</code> Works like <code>longPollingFlow</code>, but flow inside will return only the updates accumulated at the moment of calls (all new updates will not be passed throw this flow)<ul> <li><code>RequestsExecutor#retrieveAccumulatedUpdates</code> Use <code>createAccumulatedUpdatesRetrieverFlow</code> to perform all accumulated updates</li> <li><code>RequestsExecutor#flushAccumulatedUpdates</code> Works like <code>retrieveAccumulatedUpdates</code> but perform all updates directly in a place of calling</li> </ul> </li> <li>By yourself with <code>GetUpdates</code> request or <code>RequestsExecutor#getUpdates</code> extension</li> </ul>"},{"location":"tgbotapi/updates/long-polling.html#longpolling","title":"longPolling","text":"<p><code>longPolling</code> is a simple way to start getting updates and work with bot:</p> <pre><code>val bot = telegramBot(token)\nbot.longPolling(\n  textMessages().subscribe(scope) { // here \"scope\" is a CoroutineScope\n    println(it) // will be printed each update from chats with messages\n  }\n)\n</code></pre>"},{"location":"tgbotapi/updates/long-polling.html#startgettingofupdatesbylongpolling","title":"startGettingOfUpdatesByLongPolling","text":"<p>The main aim of <code>startGettingOfUpdatesByLongPolling</code> extension was to provide more simple way to get updates in automatic mode:</p> <pre><code>val bot = telegramBot(token)\nbot.startGettingOfUpdatesByLongPolling(\n  {\n    println(it) // will be printed each update from chats with messages\n  }\n)\n</code></pre> <p>The other way is to use the most basic <code>startGettingOfUpdatesByLongPolling</code> extension:</p> <pre><code>val bot = telegramBot(token)\nbot.startGettingOfUpdatesByLongPolling {\n  println(it) // will be printed each update\n}\n</code></pre>"},{"location":"tgbotapi/updates/long-polling.html#see-also","title":"See also","text":"<ul> <li>Webhooks</li> <li>Updates filters</li> </ul>"},{"location":"tgbotapi/updates/updates-filters.html","title":"Updates filters","text":"<p>Due to the fact, that anyway you will get updates in one format (<code>Update</code> objects), some time ago was solved to create one point of updates filters for more usefull way of updates handling</p>"},{"location":"tgbotapi/updates/updates-filters.html#updatesfilter","title":"UpdatesFilter","text":"<p><code>UpdatesFilter</code> currently have two properties:</p> <ul> <li><code>asUpdateReceiver</code> - required to represent this filter as common updates receiver which able to get any <code>Update</code></li> <li><code>allowedUpdates</code> - required to determine, which updates are usefull for this filter</li> </ul> <p>Anyway, this filter can\u2019t work with updates by itself. For retrieving updates you should pass this filter to some of getting updates functions (long polling or webhooks).</p>"},{"location":"tgbotapi/updates/updates-filters.html#simpleupdatesfilter","title":"SimpleUpdatesFilter","text":"<p><code>SimpleUpdatesFilter</code> is a simple variant of filters. It have a lot of <code>UpdateReceiver</code> properties which can be set up on creating of this object. For example, if you wish to get messages from chats (but not from channels), you can use next snippet:</p> <pre><code>SimpleUpdatesFilter {\n  println(it)\n}\n</code></pre>"},{"location":"tgbotapi/updates/updates-filters.html#flowsupdatesfilter","title":"FlowsUpdatesFilter","text":"<p>A little bit more modern way is to use <code>FlowsUpdatesFilter</code>. It is very powerfull API of Kotlin Coroutines Flows, built-in support of additional extensions for <code>FlowsUpdatesFilter</code> and <code>Flow&lt;...&gt;</code> receivers and opportunity to split one filter for as much receivers as you want. Filter creating example:</p> <pre><code>val scope = CoroutineScope(Dispatchers.Default)\nflowsUpdatesFilter {\n  messageFlow.onEach {\n    println(it)\n  }.launchIn(scope)\n}\n</code></pre>"},{"location":"tgbotapi/updates/updates-filters.html#combining-of-flows","title":"Combining of flows","text":"<p>In cases you need not separate logic for handling of messages from channels and chats there are three ways to combine different flows into one:</p> <ul> <li>Standard <code>plus</code> operation and handling of different flows:</li> </ul> <pre><code>flowsUpdatesFilter {\n  (messageFlow + channelPostFlow).onEach {\n    println(it) // will be printed each message update from channels and chats both\n  }.launchIn(scope)\n}\n</code></pre> <ul> <li>TelegramBotAPI library support function <code>aggregateFlows</code>:</li> </ul> <pre><code>flowsUpdatesFilter {\n  aggregateFlows(\n    scope,\n    messageFlow,\n    channelPostFlow\n  ).onEach {\n    println(it) // will be printed each message update from channels and chats both\n  }.launchIn(scope)\n}\n</code></pre> <ul> <li><code>FlowsUpdatesFilter</code> extensions:</li> </ul> <pre><code>flowsUpdatesFilter {\n  allSentMessagesFlow.onEach {\n    println(it) // will be printed each message update from channels and chats both\n  }.launchIn(scope)\n}\n</code></pre>"},{"location":"tgbotapi/updates/updates-filters.html#types-filtering","title":"Types filtering","text":"<p><code>FlowsUpdatesFilter</code> have a lot of extensions for messages types filtering:</p> <pre><code>flowsUpdatesFilter {\n  textMessages(scope).onEach {\n    println(it) // will be printed each message from channels and chats both with content only `TextContent`\n  }.launchIn(scope)\n}\n</code></pre> <p>The same things were created for media groups:</p> <pre><code>flowsUpdatesFilter {\n  mediaGroupMessages(scope).onEach {\n    println(it) // will be printed each media group messages list from both channels and chats without filtering of content\n  }.launchIn(scope)\n\n  mediaGroupPhotosMessages(scope).onEach {\n    println(it) // will be printed each media group messages list from both channels and chats with PhotoContent only\n  }.launchIn(scope)\n\n  mediaGroupVideosMessages(scope).onEach {\n    println(it) // will be printed each media group messages list from both channels and chats with VideoContent only\n  }.launchIn(scope)\n}\n</code></pre> <p>Besides, there is an opportunity to avoid separation on media groups and common messages and receive photos and videos content in one flow:</p> <pre><code>flowsUpdatesFilter {\n  sentMessagesWithMediaGroups(scope).onEach {\n    println(it) // will be printed each message including each separated media group message from both channels and chats without filtering of content\n  }.launchIn(scope)\n\n  photoMessagesWithMediaGroups(scope).onEach {\n    println(it) // will be printed each message including each separated media group message from both channels and chats with PhotoContent only\n  }.launchIn(scope)\n\n  videoMessagesWithMediaGroups(scope).onEach {\n    println(it) // will be printed each message including each separated media group message from both channels and chats with VideoContent only\n  }.launchIn(scope)\n}\n</code></pre>"},{"location":"tgbotapi/updates/updates-filters.html#see-also","title":"See also","text":"<ul> <li>Long polling</li> <li>Webhooks</li> </ul>"},{"location":"tgbotapi/updates/webhooks.html","title":"Webhooks","text":"<p>In telegram bot API there is an opportunity to get updates via webhooks. In this case you will be able to retrieve updates without making additional requests. Most of currently available methods for webhooks are working on ktor server for JVM. Currently, next ways are available for using for webhooks:</p> <ul> <li><code>Route#includeWebhookHandlingInRoute</code> for ktor server</li> <li><code>Route#includeWebhookHandlingInRouteWithFlows</code> </li> <li><code>startListenWebhooks</code></li> <li><code>RequestsExecutor#setWebhookInfoAndStartListenWebhooks</code></li> </ul>"},{"location":"tgbotapi/updates/webhooks.html#setwebhookinfoandstartlistenwebhooks","title":"<code>setWebhookInfoAndStartListenWebhooks</code>","text":"<p>It is the most common way to set updates webhooks and start listening of them. Example:</p> <pre><code>val bot = telegramBot(TOKEN)\n\nval filter = flowsUpdatesFilter {\n  // ...\n}\n\nbot.setWebhookInfoAndStartListenWebhooks(\n  8080, // listening port. It is required for cases when your server hidden by some proxy or other system like Heroku\n  CIO, // default ktor server engine. It is recommended to replace it with something like `Netty`. More info about engines here: https://ktor.io/servers/configuration.html\n  SetWebhook(\n    \"address.com/webhook_route\",\n    File(\"/path/to/certificate\").toInputFile(), // certificate file. More info here: https://core.telegram.org/bots/webhooks#a-certificate-where-do-i-get-one-and-how\n    40, // max allowed updates, by default is null\n    filter.allowedUpdates\n  ),\n  {\n    it.printStackTrace() // optional handling of exceptions\n  },\n  \"0.0.0.0\", // listening host which will be used to bind by server\n  \"subroute\", // Optional subroute, if null - will listen root of address\n  WebhookPrivateKeyConfig( // optional config of private key. It will be installed in server to use TLS with custom certificate. More info here: https://core.telegram.org/bots/webhooks#a-certificate-where-do-i-get-one-and-how\n    \"/path/to/keystore.jks\",\n    \"KeystorePassword\",\n    \"Keystore key alias name\",\n    \"KeystoreAliasPassword\"\n  ),\n  scope, // Kotlin coroutine scope for internal transforming of media groups\n  filter.asUpdateReceiver\n)\n</code></pre> <p>If you will use previous example, ktor server will bind and listen url <code>0.0.0.0:8080/subroute</code> and telegram will send requests to address <code>address.com/webhook_route</code> with custom certificate. Alternative variant will use the other <code>SetWebhook</code> request variant:</p> <pre><code>SetWebhook(\n  \"address.com/webhook_route\",\n  \"some_file_bot_id\".toInputFile(),\n  40, // max allowed updates, by default is null\n  filter.allowedUpdates\n)\n</code></pre> <p>As a result, request <code>SetWebhook</code> will be executed and after this server will start its working and handling of updates.</p>"},{"location":"tgbotapi/updates/webhooks.html#startlistenwebhooks","title":"<code>startListenWebhooks</code>","text":"<p>This function is working almost exactly like previous example, but this one will not set up webhook info in telegram:</p> <pre><code>val filter = flowsUpdatesFilter {\n  // ...\n}\n\nstartListenWebhooks(\n  8080, // listening port. It is required for cases when your server hidden by some proxy or other system like Heroku\n  CIO, // default ktor server engine. It is recommended to replace it with something like `Netty`. More info about engines here: https://ktor.io/servers/configuration.html\n  {\n    it.printStackTrace() // optional handling of exceptions\n  },\n  \"0.0.0.0\", // listening host which will be used to bind by server\n  \"subroute\", // Optional subroute, if null - will listen root of address\n  WebhookPrivateKeyConfig( // optional config of private key. It will be installed in server to use TLS with custom certificate. More info here: https://core.telegram.org/bots/webhooks#a-certificate-where-do-i-get-one-and-how\n    \"/path/to/keystore.jks\",\n    \"KeystorePassword\",\n    \"Keystore key alias name\",\n    \"KeystoreAliasPassword\"\n  ),\n  scope, // Kotlin coroutine scope for internal transforming of media groups\n  filter.asUpdateReceiver\n)\n</code></pre> <p>The result will be the same as in previous example: server will start its working and handling of updates on <code>0.0.0.0:8080/subroute</code>. The difference here is that in case if this bot must not answer or send some requiests - it will not be necessary to create bot for receiving of updates.</p>"},{"location":"tgbotapi/updates/webhooks.html#extensions-includewebhookhandlinginroute-and-includewebhookhandlinginroutewithflows","title":"Extensions <code>includeWebhookHandlingInRoute</code> and <code>includeWebhookHandlingInRouteWithFlows</code>","text":"<p>For these extensions you will need to start your server manualy. In common case it will look like:</p> <pre><code>val scope = CoroutineScope(Dispatchers.Default)\n\nval filter = flowsUpdatesFilter {\n  // ...\n}\n\nval environment = applicationEngineEnvironment {\n  module {\n    routing {\n      includeWebhookHandlingInRoute(\n        scope,\n        {\n          it.printStackTrace()\n        },\n        filter.asUpdateReceiver\n      )\n    }\n  }\n  connector {\n    host = \"0.0.0.0\"\n    port = 8080\n  }\n}\n\nembeddedServer(CIO, environment).start(true) // will start server and wait its stoping\n</code></pre> <p>In the example above server will started and binded for listening on <code>0.0.0.0:8080</code>.</p>"},{"location":"tgbotapi/updates/webhooks.html#see-also","title":"See also","text":"<ul> <li>Updates filters</li> <li>Long polling</li> </ul>"}]}